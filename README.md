Лабораторна робота №8


1. М’ютекс (mutex)

Забезпечує взаємовиключення, дозволяючи лише одному потоку одночасно працювати у критичній секції.

2. Семафори (sem_t)

Застосовуються для контролю кількості доступних ресурсів.

У задачі виробника–споживача використовують:

empty_slots — кількість вільних позицій у буфері

full_slots — кількість зайнятих позицій

3. Умовні змінні (pthread_cond_t)

Дозволяють потокам очікувати подію, не блокуючи CPU.



 Опис лабораторної роботи

Реалізовано два завдання.

Task 1. Семафори та циклічний буфер

У першому завданні була реалізована багатопотокова система типу «Виробник–Споживач» з використанням семафорів і циклічного буфера. Створюється декілька потоків-виробників і один потік-споживач. Виробники генерують випадкові числа та записують їх у спільний циклічний буфер розміром 10 елементів. Споживач, у свою чергу, постійно забирає значення з буфера.

Для синхронізації використано два семафори: empty_slots (кількість вільних місць у буфері) і full_slots (кількість зайнятих місць). Виробник перед записом у буфер виконує sem_wait(empty_slots), чим гарантує, що буфер не буде переповнений. Споживач перед читанням виконує sem_wait(full_slots), щоб не читати з порожнього буфера. Також застосовується м’ютекс для захисту критичної секції під час читання та запису елементів. Буфер реалізований як циклічний масив з індексами head і tail.

Система працює певний час (близько 10 секунд), після чого всі потоки коректно завершують роботу. Таке рішення демонструє правильне використання семафорів для контролю доступу до ресурсу, що має обмежений розмір, а також дозволяє запобігти переповненню та некоректному читанню даних.

Task 2. Умовні змінні (Condition Variables)

У другому завданні реалізовано спрощений варіант задачі «Виробник–Споживач», але з використанням умовних змінних (pthread_cond_t) замість семафорів. Тут використовується буфер розміром один елемент. Існує один потік-виробник і один потік-споживач.

Виробник з певною періодичністю (приблизно раз на секунду) генерує нове число, але перед записом він перевіряє, чи буфер не зайнятий. Якщо дані там ще не були спожиті, він переходить у стан очікування за допомогою pthread_cond_wait. Споживач, навпаки, очікує появи нового значення. Як тільки виробник кладе в буфер нові дані, він надсилає сигнал pthread_cond_signal, завдяки якому споживач прокидається, забирає число та знову повідомляє умовну змінну, що буфер звільнений.

Таким чином, обидва потоки працюють у режимі чіткого чергування: спочатку виробник генерує дані, потім споживач їх приймає. Буфер ніколи не переповнюється і не читається у порожньому стані. Це типовий приклад застосування умовних змінних для синхронізації доступу до ресурсу, коли важливо організувати очікування певної події, а не просто обмежувати кількість ресурсів, як у випадку з семафорами.
